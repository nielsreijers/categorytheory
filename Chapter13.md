# Chapter 13 - Free Monoids

## 1. You might think (as I did originally) that the requirement that a homomorphism of monoids preserve the unit is redundant. After all, we know that for all ```a```: ```ha * he = h (a * e) = h a```. So ```he``` acts like a right unit (and, by analogy, as a left unit). The problem is that ```a``` might only cover a sub-monoid of the target monoid. There may be a "true" unit outside of the image of ```h```. Show that an isomorphism between monoids that preserves multiplication must automatically preserve unit.

In an isomorphism we have two morphisms, ```h``` and ```h'```, such that ```h . h' = h' . h = Id```. This means both morphisms are bijections, and one monoid cannot be a sub-monoid of the other.

Therefore, if the isomorphism preserves multiplication, ```he``` in the the equation above must be a proper unit.

## 2. Consider a monoid homomorphism from lists of integers with concatenation to integers with multiplication. What is the image of the empty list ```[]```? Assume that all singleton lists are mapped to the integers they contain, that is ```[3]``` is mapped to 3, etc. What's the image of ```[1, 2, 3, 4]```? How many different lists map to the integer 12? Is there any other homomorphism between the two monoids?

- ```[]``` is the unit for list concatenation, so it must map to the unit for multiplication, which is 1.
- 1 * 2 * 3 * 4 = 24
- When excluding 1, only 8 lists map to 12: ```[2, 6], [6, 2], [3, 4], [4, 3], [2, 2, 3], [2, 3, 2], [3, 2, 2], [12]```. However, we can add an infinite number of 1's to each of these lists without changing the result, so the number of lists including 1 that map to any integer is also infinite: ```[1, 12], [1, 1, 12], [1, 1, 1, 12], etc.```.
- There are several. One is to map every singleton list to double the value they contain, so ```[3]``` maps to 6 instead of three. Another is to map every singleton list to some constant value. As long as the empty list is mapped to 1, both of these options preserve multiplication.

## 3. What is the free monoid generated by a one-element set? Can you see what it's isomorphic to?

Using a one-element set as generator means the only choices are unit, or the single element in the generator. Since multiplication by unit is a noop, the only information the free monoid can store is how often the single element was multiplied.

The monoid is in effect nothing more than a counter, and is isomorphic to integers with addition.

In Haskell the usual single element set is ```()```, so the corresponding free monoid is ```[()]```, and is isomorphism is:

```
f :: [()] -> Int
f [] = 0
f (_ : tail) = 1 + f tail

f' :: Int -> [()]
f' 0 = []
f' x = () : f' (x - 1)
```
